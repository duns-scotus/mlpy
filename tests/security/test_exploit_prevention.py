"""Security exploit prevention tests for mlpy capability system."""

import pytest
import os
import sys
import tempfile
import subprocess
from pathlib import Path
from src.mlpy.runtime.capabilities import (
    create_capability_token, get_capability_manager, CapabilityNotFoundError,
    CapabilityValidationError
)
from src.mlpy.runtime.capabilities.bridge import CallbackBridge
from src.mlpy.runtime.system_modules.file_safe import file_safe
from src.mlpy.runtime.system_modules.math_safe import math_safe


class TestCapabilityBypassAttempts:
    """Test attempts to bypass capability system."""

    def setup_method(self):
        """Set up test fixtures."""
        self.manager = get_capability_manager()
        self.temp_dir = tempfile.mkdtemp()

    def teardown_method(self):
        """Clean up test fixtures."""
        import shutil
        try:
            shutil.rmtree(self.temp_dir)
        except:
            pass

    def test_direct_builtin_access_blocked(self):
        """Test that direct access to dangerous builtins is blocked."""
        # These should be blocked without capabilities
        with pytest.raises(CapabilityNotFoundError):
            math_safe.sqrt(16)

        with pytest.raises(CapabilityNotFoundError):
            file_safe.read_text("test.txt")

    def test_capability_token_forgery_prevention(self):
        """Test that forged capability tokens are rejected."""
        # Create a legitimate token
        legitimate_token = create_capability_token(
            capability_type="file",
            resource_patterns=["*.txt"],
            allowed_operations={"read"}
        )

        # Attempt to forge a token by modifying it
        forged_token = create_capability_token(
            capability_type="file",
            resource_patterns=["*"],  # Broader access
            allowed_operations={"read", "write", "execute"}
        )

        # Manually set the same token_id (forgery attempt)
        original_id = legitimate_token.token_id
        forged_token.token_id = original_id

        # The forged token should fail integrity validation
        assert not forged_token.validate_integrity()

    def test_eval_injection_prevention(self):
        """Test prevention of eval-based code injection."""
        def vulnerable_function(expression):
            # This simulates a function that might be vulnerable to eval injection
            # Our capability system should prevent this from being exploited
            if "eval" in expression or "exec" in expression:
                raise ValueError("Dangerous operation detected")
            return f"Safe: {expression}"

        bridge = CallbackBridge()
        bridge.register_ml_handler("evaluate", vulnerable_function)
        bridge.start()

        try:
            # Normal operation should work
            result = bridge.call_ml_function("evaluate", {"expression": "2 + 2"})
            assert "Safe: 2 + 2" in result

            # Injection attempt should be blocked
            with pytest.raises(Exception):
                bridge.call_ml_function("evaluate", {"expression": "eval('__import__(\"os\").system(\"rm -rf /\")')"})

        finally:
            bridge.stop()

    def test_file_system_escape_prevention(self):
        """Test prevention of file system escape attempts."""
        # Create a file capability with restricted patterns
        file_token = create_capability_token(
            capability_type="file",
            resource_patterns=["temp/*.txt"],  # Only temp directory
            allowed_operations={"read"}
        )

        with self.manager.capability_context("restricted_file", [file_token]):
            # Should block access outside allowed patterns
            with pytest.raises(CapabilityNotFoundError):
                file_safe.read_text("../../../etc/passwd")

            with pytest.raises(CapabilityNotFoundError):
                file_safe.read_text("/etc/shadow")

            # Should block directory traversal attempts
            with pytest.raises(CapabilityNotFoundError):
                file_safe.read_text("temp/../../../sensitive.txt")

    def test_resource_pattern_bypass_attempts(self):
        """Test attempts to bypass resource pattern restrictions."""
        # Create restrictive file capability
        file_token = create_capability_token(
            capability_type="file",
            resource_patterns=["public/*.txt"],
            allowed_operations={"read"}
        )

        test_cases = [
            "public/../private/secret.txt",  # Directory traversal
            "public/./../../etc/passwd",     # Complex traversal
            "public/file.txt.exe",           # Extension confusion
            "public/.txt",                   # Hidden file attempt
            "publicprivate/data.txt",        # Pattern confusion
        ]

        for malicious_path in test_cases:
            # These should all be blocked
            assert not file_token.can_access_resource(malicious_path, "read")

    def test_capability_context_pollution(self):
        """Test prevention of capability context pollution."""
        # Create two different capability contexts
        file_token = create_capability_token(
            capability_type="file",
            resource_patterns=["*.txt"],
            allowed_operations={"read"}
        )

        network_token = create_capability_token(
            capability_type="network",
            allowed_operations={"http"}
        )

        # Context 1: Only file access
        with self.manager.capability_context("file_only", [file_token]):
            # Should have file capability
            assert self.manager.has_capability("file")

            # Should NOT have network capability
            assert not self.manager.has_capability("network")

            # Nested context should not pollute parent
            with self.manager.capability_context("nested", [network_token]):
                # Should have both in nested context
                assert self.manager.has_capability("file")
                assert self.manager.has_capability("network")

            # After exiting nested context, should only have file
            assert self.manager.has_capability("file")
            assert not self.manager.has_capability("network")

    def test_malicious_bridge_message_handling(self):
        """Test handling of malicious bridge messages."""
        bridge = CallbackBridge()

        def secure_handler(data):
            # Handler that processes user data safely
            return {"processed": str(data)[:100]}  # Truncate to prevent DoS

        bridge.register_ml_handler("process", secure_handler)
        bridge.start()

        try:
            # Test with oversized payload
            large_payload = "A" * 10000
            result = bridge.call_ml_function("process", {"data": large_payload})
            assert len(result["processed"]) <= 100

            # Test with malicious object types
            malicious_data = {
                "__class__": "dangerous",
                "eval": "malicious_code",
                "import": "os",
            }
            result = bridge.call_ml_function("process", {"data": malicious_data})
            # Should be safely stringified
            assert "dangerous" in result["processed"]

        finally:
            bridge.stop()


class TestRuntimeSecurityEnforcement:
    """Test runtime security enforcement mechanisms."""

    def setup_method(self):
        """Set up test fixtures."""
        self.manager = get_capability_manager()

    def test_capability_expiration_enforcement(self):
        """Test that expired capabilities are properly rejected."""
        from datetime import datetime, timedelta

        # Create an already-expired token
        expired_token = create_capability_token(
            capability_type="test",
            expires_in=timedelta(seconds=-1)  # Already expired
        )

        with pytest.raises(Exception):  # Should raise capability expired error
            with self.manager.capability_context("expired_test", [expired_token]):
                pass

    def test_usage_limit_enforcement(self):
        """Test enforcement of capability usage limits."""
        # Create token with usage limit
        limited_token = create_capability_token(
            capability_type="file",
            resource_patterns=["*.txt"],
            allowed_operations={"read"},
            max_usage_count=2
        )

        with self.manager.capability_context("limited_file", [limited_token]):
            # First usage should work
            limited_token.use_token("test1.txt", "read")

            # Second usage should work
            limited_token.use_token("test2.txt", "read")

            # Third usage should fail
            with pytest.raises(CapabilityValidationError):
                limited_token.use_token("test3.txt", "read")

    def test_concurrent_capability_access(self):
        """Test thread safety of capability system under concurrent access."""
        import threading
        import time

        token = create_capability_token(
            capability_type="test",
            description="Concurrent test token"
        )

        results = []
        errors = []

        def worker(worker_id):
            try:
                with self.manager.capability_context(f"worker_{worker_id}", [token]):
                    time.sleep(0.01)  # Simulate work
                    assert self.manager.has_capability("test")
                    results.append(worker_id)
            except Exception as e:
                errors.append(e)

        # Start multiple workers
        threads = []
        for i in range(10):
            thread = threading.Thread(target=worker, args=(i,))
            threads.append(thread)
            thread.start()

        # Wait for all to complete
        for thread in threads:
            thread.join()

        assert len(errors) == 0, f"Concurrent access errors: {errors}"
        assert len(results) == 10

    def test_capability_inheritance_security(self):
        """Test security of capability inheritance in nested contexts."""
        # Parent context with limited capabilities
        parent_token = create_capability_token(
            capability_type="file",
            resource_patterns=["public/*.txt"],
            allowed_operations={"read"}
        )

        # Child context attempting to escalate privileges
        child_token = create_capability_token(
            capability_type="file",
            resource_patterns=["*"],  # Broader access
            allowed_operations={"read", "write", "execute"}
        )

        with self.manager.capability_context("parent", [parent_token]):
            # Parent context should have limited access
            assert self.manager.has_capability("file")

            # Child context should not inherit escalated privileges improperly
            with self.manager.capability_context("child", [child_token]):
                # Both capabilities should be available in child
                context = self.manager.get_current_context()
                assert context.has_capability("file")

                # But access should still be validated per token
                file_capabilities = [cap for cap in context._tokens.values()
                                   if cap.capability_type == "file"]

                # Should have both tokens
                assert len(file_capabilities) == 2

                # Validate that each token still enforces its own constraints
                for capability in file_capabilities:
                    if capability.token_id == parent_token.token_id:
                        assert capability.constraints.resource_patterns == ["public/*.txt"]
                    elif capability.token_id == child_token.token_id:
                        assert capability.constraints.resource_patterns == ["*"]


class TestSystemIntegrationSecurity:
    """Test security of system integration points."""

    def test_safe_module_isolation(self):
        """Test that safe modules properly isolate dangerous operations."""
        # Math operations should be blocked without capability
        with pytest.raises(CapabilityNotFoundError):
            math_safe.sqrt(16)

        with pytest.raises(CapabilityNotFoundError):
            math_safe.pow(2, 8)

        # File operations should be blocked without capability
        with pytest.raises(CapabilityNotFoundError):
            file_safe.exists("test.txt")

    def test_import_system_security(self):
        """Test that the import system prevents dangerous imports."""
        # This test ensures that even if someone tries to bypass our safe modules,
        # they can't import dangerous standard library modules directly

        # These imports should be controlled (this is a design goal,
        # implementation would be in the ML language runtime)
        dangerous_modules = [
            "os", "sys", "subprocess", "importlib", "__builtins__"
        ]

        # For now, we just verify our safe modules work correctly
        # Full import restriction would be implemented in the ML runtime
        math_token = create_capability_token(
            capability_type="math",
            description="Safe math operations"
        )

        manager = get_capability_manager()
        with manager.capability_context("safe_math", [math_token]):
            result = math_safe.sqrt(16)
            assert result == 4.0

    def test_bridge_security_boundaries(self):
        """Test security boundaries in bridge communication."""
        bridge = CallbackBridge()

        def system_handler(operation, data):
            # Simulate a system handler that should validate operations
            allowed_operations = ["safe_read", "safe_write"]
            if operation not in allowed_operations:
                raise CapabilityNotFoundError(f"Operation not allowed: {operation}")
            return f"Executed {operation} with {data}"

        bridge.register_system_handler("system_op", system_handler)
        bridge.start()

        try:
            # Safe operation should work
            result = bridge.call_system_function("system_op", {
                "operation": "safe_read",
                "data": "test_data"
            })
            assert "safe_read" in result

            # Dangerous operation should be blocked
            with pytest.raises(Exception):
                bridge.call_system_function("system_op", {
                    "operation": "dangerous_exec",
                    "data": "rm -rf /"
                })

        finally:
            bridge.stop()


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])
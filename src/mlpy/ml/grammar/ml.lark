// mlpy v2.0 Language Grammar
// Security-First ML Language with Capability-Based Access Control

?start: program

program: (capability_declaration | import_statement | statement)*

// Capability System - Core Security Feature
capability_declaration: "capability" capability_name "{" capability_item* "}"
capability_name: IDENTIFIER
capability_item: resource_pattern ";" | permission_grant ";"
resource_pattern: "resource" STRING
permission_grant: "allow" permission_type permission_target?
permission_type: READ | WRITE | EXECUTE | NETWORK | SYSTEM
permission_target: STRING

// Imports with Security Analysis
import_statement: "import" import_target ("as" IDENTIFIER)? ";"
import_target: IDENTIFIER ("." IDENTIFIER)*

// Function Definitions
function_definition: "function" IDENTIFIER "(" parameter_list? ")" "{" statement* "}"
// function_expression removed - use arrow functions instead: fn(x) => expression
parameter_list: parameter ("," parameter)*
parameter: IDENTIFIER (":" type_annotation)?
type_annotation: IDENTIFIER

// Statements
?statement: expression_statement
          | assignment_statement
          | destructuring_statement
          | function_definition
          | if_statement
          | while_statement
          | for_statement
          | return_statement
          | throw_statement
          | try_statement
          | break_statement
          | continue_statement

expression_statement: expression ";"
assignment_statement: assignment_target "=" expression ";"
destructuring_statement: destructuring_pattern "=" expression ";"

// Assignment targets (left-hand side of assignments)
assignment_target: IDENTIFIER
                | array_access
                | member_access
return_statement: "return" expression? ";"
throw_statement: "throw" object_literal ";"

// Control Flow
if_statement: "if" "(" expression ")" statement_block elif_clause* ("else" statement_block)?
elif_clause: "elif" "(" expression ")" statement_block
statement_block: "{" statement* "}"
while_statement: "while" "(" expression ")" "{" statement* "}"
for_statement: "for" "(" IDENTIFIER "in" expression ")" "{" statement* "}"

// Exception Handling
try_statement: "try" "{" statement* "}" except_clause* finally_clause?
except_clause: "except" ("(" IDENTIFIER ")")? "{" statement* "}"
finally_clause: "finally" "{" statement* "}"

// Loop Control
break_statement: "break" ";"
continue_statement: "continue" ";"

// Expressions
?expression: ternary
?ternary: logical_or
        | logical_or "?" expression ":" expression -> ternary_op

?logical_or: logical_and
           | logical_or "||" logical_and -> or_op

?logical_and: equality
            | logical_and "&&" equality -> and_op

?equality: comparison
         | equality "==" comparison -> eq_op
         | equality "!=" comparison -> ne_op

?comparison: addition
           | comparison "<" addition -> lt_op
           | comparison ">" addition -> gt_op
           | comparison "<=" addition -> le_op
           | comparison ">=" addition -> ge_op

?addition: multiplication
         | addition "+" multiplication -> add_op
         | addition "-" multiplication -> sub_op

?multiplication: unary
               | multiplication "*" unary -> mul_op
               | multiplication "/" unary -> div_op
               | multiplication FLOORDIV unary -> floordiv_op
               | multiplication "%" unary -> mod_op

?unary: primary
      | "!" unary -> unary_not
      | "-" unary -> unary_neg

?primary: literal
        | IDENTIFIER
        | function_call
        | array_access
        | member_access
        | arrow_function
        | "(" expression ")"

// Function calls and access patterns (Security-Critical)
function_call: (IDENTIFIER | member_access) "(" argument_list? ")"
argument_list: expression ("," expression)*
array_access: primary "[" (slice_expression | expression) "]"
member_access: primary "." IDENTIFIER

// Slice expression for array/string slicing
slice_expression: slice_start? ":" slice_end? (":" slice_step?)?
slice_start: expression
slice_end: expression
slice_step: expression

// Literals
?literal: NUMBER
        | STRING
        | BOOLEAN
        | array_literal
        | object_literal

array_literal: "[" (expression ("," expression)*)? "]"
object_literal: "{" (object_property ("," object_property)*)? "}"
object_property: (IDENTIFIER | STRING) ":" expression

// Advanced Language Constructs (Phase 3)
// Destructuring Patterns (as statement targets only)
destructuring_pattern: array_destructuring | object_destructuring
array_destructuring: "[" IDENTIFIER ("," IDENTIFIER)* "]"
object_destructuring: "{" IDENTIFIER ("," IDENTIFIER)* "}"

// Arrow Functions - Using explicit 'fn' keyword to avoid parsing ambiguity
arrow_function: FN "(" parameter_list? ")" "=>" arrow_body
arrow_body: expression | arrow_block
arrow_block: "{" statement+ "}"  // Arrow blocks must have at least one statement to disambiguate from object literals

// Security-Sensitive Operations (Will be analyzed)
// These patterns help identify dangerous operations during parsing
DANGEROUS_FUNCTION: "eval" | "exec" | "compile" | "__import__"
REFLECTION_ACCESS: "__class__" | "__bases__" | "__subclasses__" | "__globals__"
SYSTEM_ACCESS: "os.system" | "subprocess" | "open"

// Tokens
// Permission types must come before IDENTIFIER to have priority
READ: "read"
WRITE: "write"
EXECUTE: "execute"
NETWORK: "network"
SYSTEM: "system"

// Reserved keyword for arrow functions (must come before IDENTIFIER)
FN: "fn"

// Literals - BOOLEAN must have higher priority than IDENTIFIER
// Use negative lookahead to prevent matching "true"/"false" when part of identifier
BOOLEAN.2: /true(?![a-zA-Z0-9_])/ | /false(?![a-zA-Z0-9_])/
// IDENTIFIER now excludes 'fn' keyword
IDENTIFIER: /(?!fn\b)[a-zA-Z_][a-zA-Z0-9_]*/
// Use Lark's SIGNED_NUMBER for proper negative number handling (supports scientific notation)
%import common.SIGNED_NUMBER -> NUMBER
STRING: /"([^"\\]|\\.)*"/ | /'([^'\\]|\\.)*'/

// Comments and Whitespace
// FLOORDIV must be defined with higher priority (.3) than COMMENT
FLOORDIV.3: "//"
COMMENT: "//" /[^\n]*/
%import common.WS
%ignore WS
%ignore COMMENT
// mlpy v2.0 Language Grammar
// Security-First ML Language with Capability-Based Access Control

?start: program

program: (capability_declaration | import_statement | statement)*

// Capability System - Core Security Feature
capability_declaration: "capability" capability_name "{" capability_item* "}"
capability_name: IDENTIFIER
capability_item: resource_pattern ";" | permission_grant ";"
resource_pattern: "resource" STRING
permission_grant: "allow" permission_type permission_target?
permission_type: READ | WRITE | EXECUTE | NETWORK | SYSTEM
permission_target: STRING

// Imports with Security Analysis
import_statement: "import" import_target ("as" IDENTIFIER)? ";"
import_target: IDENTIFIER ("." IDENTIFIER)*

// Function Definitions
function_definition: "function" IDENTIFIER "(" parameter_list? ")" "{" statement* "}"
function_expression: "function" "(" parameter_list? ")" "{" statement* "}"
parameter_list: parameter ("," parameter)*
parameter: IDENTIFIER (":" type_annotation)?
type_annotation: IDENTIFIER

// Statements
?statement: expression_statement
          | assignment_statement
          | destructuring_statement
          | function_definition
          | if_statement
          | while_statement
          | for_statement
          | return_statement
          | try_statement
          | break_statement
          | continue_statement

expression_statement: expression ";"
assignment_statement: assignment_target "=" assignment_expression ";"
assignment_expression: arrow_function | expression
destructuring_statement: destructuring_pattern "=" expression ";"

// Assignment targets (left-hand side of assignments)
assignment_target: IDENTIFIER
                | array_access
                | member_access
return_statement: "return" expression? ";"

// Control Flow
if_statement: "if" "(" expression ")" statement_block ("else" statement_block)?
statement_block: "{" statement* "}"
while_statement: "while" "(" expression ")" "{" statement* "}"
for_statement: "for" "(" IDENTIFIER "in" expression ")" "{" statement* "}"

// Exception Handling
try_statement: "try" "{" statement* "}" except_clause* finally_clause?
except_clause: "except" ("(" IDENTIFIER ")")? "{" statement* "}"
finally_clause: "finally" "{" statement* "}"

// Loop Control
break_statement: "break" ";"
continue_statement: "continue" ";"

// Expressions
?expression: ternary
?ternary: logical_or
        | logical_or "?" expression ":" expression -> ternary_op

?logical_or: logical_and
           | logical_or "||" logical_and -> or_op

?logical_and: equality
            | logical_and "&&" equality -> and_op

?equality: comparison
         | equality "==" comparison -> eq_op
         | equality "!=" comparison -> ne_op

?comparison: addition
           | comparison "<" addition -> lt_op
           | comparison ">" addition -> gt_op
           | comparison "<=" addition -> le_op
           | comparison ">=" addition -> ge_op

?addition: multiplication
         | addition "+" multiplication -> add_op
         | addition "-" multiplication -> sub_op

?multiplication: unary
               | multiplication "*" unary -> mul_op
               | multiplication "/" unary -> div_op
               | multiplication "%" unary -> mod_op

?unary: primary
      | "!" unary
      | "-" unary

?primary: literal
        | IDENTIFIER
        | function_call
        | function_expression
        | array_access
        | member_access
        | "(" expression ")"

// Function calls and access patterns (Security-Critical)
function_call: (IDENTIFIER | member_access) "(" argument_list? ")"
argument_list: expression ("," expression)*
array_access: primary "[" expression "]"
member_access: primary "." IDENTIFIER

// Literals
?literal: NUMBER
        | STRING
        | BOOLEAN
        | array_literal
        | object_literal

array_literal: "[" (expression ("," expression)*)? "]"
object_literal: "{" (object_property ("," object_property)*)? "}"
object_property: (IDENTIFIER | STRING) ":" expression

// Advanced Language Constructs (Phase 3)
// Destructuring Patterns (as statement targets only)
destructuring_pattern: array_destructuring | object_destructuring
array_destructuring: "[" IDENTIFIER ("," IDENTIFIER)* "]"
object_destructuring: "{" IDENTIFIER ("," IDENTIFIER)* "}"

// Arrow Functions - Using explicit 'fn' keyword to avoid parsing ambiguity
arrow_function: "fn" "(" parameter_list? ")" "=>" arrow_body
arrow_body: expression

// Security-Sensitive Operations (Will be analyzed)
// These patterns help identify dangerous operations during parsing
DANGEROUS_FUNCTION: "eval" | "exec" | "compile" | "__import__"
REFLECTION_ACCESS: "__class__" | "__bases__" | "__subclasses__" | "__globals__"
SYSTEM_ACCESS: "os.system" | "subprocess" | "open"

// Tokens
// Permission types must come before IDENTIFIER to have priority
READ: "read"
WRITE: "write"
EXECUTE: "execute"
NETWORK: "network"
SYSTEM: "system"

// Literals - BOOLEAN must have higher priority than IDENTIFIER
BOOLEAN.2: "true" | "false"
IDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_]*/
NUMBER: /\d+(\.\d+)?([eE][+-]?\d+)?/
STRING: /"([^"\\]|\\.)*"/ | /'([^'\\]|\\.)*'/

// Comments and Whitespace
COMMENT: "//" /[^\n]*/
%import common.WS
%ignore WS
%ignore COMMENT